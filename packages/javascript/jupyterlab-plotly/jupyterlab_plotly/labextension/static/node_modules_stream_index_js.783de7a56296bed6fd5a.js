(self["webpackChunkjupyterlab_plotly"] = self["webpackChunkjupyterlab_plotly"] || []).push([["node_modules_stream_index_js"],{

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/***/ ((module) => {

function Emitter(object) {
	if (object) {
		return mixin(object);
	}

	this._callbacks = new Map();
}

function mixin(object) {
	Object.assign(object, Emitter.prototype);
	object._callbacks = new Map();
	return object;
}

Emitter.prototype.on = function (event, listener) {
	const callbacks = this._callbacks.get(event) ?? [];
	callbacks.push(listener);
	this._callbacks.set(event, callbacks);
	return this;
};

Emitter.prototype.once = function (event, listener) {
	const on = (...arguments_) => {
		this.off(event, on);
		listener.apply(this, arguments_);
	};

	on.fn = listener;
	this.on(event, on);
	return this;
};

Emitter.prototype.off = function (event, listener) {
	if (event === undefined && listener === undefined) {
		this._callbacks.clear();
		return this;
	}

	if (listener === undefined) {
		this._callbacks.delete(event);
		return this;
	}

	const callbacks = this._callbacks.get(event);
	if (callbacks) {
		for (const [index, callback] of callbacks.entries()) {
			if (callback === listener || callback.fn === listener) {
				callbacks.splice(index, 1);
				break;
			}
		}

		if (callbacks.length === 0) {
			this._callbacks.delete(event);
		} else {
			this._callbacks.set(event, callbacks);
		}
	}

	return this;
};

Emitter.prototype.emit = function (event, ...arguments_) {
	const callbacks = this._callbacks.get(event);
	if (callbacks) {
		// Create a copy of the callbacks array to avoid issues if it's modified during iteration
		const callbacksCopy = [...callbacks];

		for (const callback of callbacksCopy) {
			callback.apply(this, arguments_);
		}
	}

	return this;
};

Emitter.prototype.listeners = function (event) {
	return this._callbacks.get(event) ?? [];
};

Emitter.prototype.listenerCount = function (event) {
	if (event) {
		return this.listeners(event).length;
	}

	let totalCount = 0;
	for (const callbacks of this._callbacks.values()) {
		totalCount += callbacks.length;
	}

	return totalCount;
};

Emitter.prototype.hasListeners = function (event) {
	return this.listenerCount(event) > 0;
};

// Aliases
Emitter.prototype.addEventListener = Emitter.prototype.on;
Emitter.prototype.removeListener = Emitter.prototype.off;
Emitter.prototype.removeEventListener = Emitter.prototype.off;
Emitter.prototype.removeAllListeners = Emitter.prototype.off;

if (true) {
	module.exports = Emitter;
}


/***/ }),

/***/ "./node_modules/stream/index.js":
/*!**************************************!*\
  !*** ./node_modules/stream/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

function Stream() {
  Emitter.call(this);
}
Stream.prototype = new Emitter();
module.exports = Stream;
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (!this.hasListeners('error')) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.off('data', ondata);
    dest.off('drain', ondrain);

    source.off('end', onend);
    source.off('close', onclose);

    source.off('error', onerror);
    dest.off('error', onerror);

    source.off('end', cleanup);
    source.off('close', cleanup);

    dest.off('end', cleanup);
    dest.off('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('end', cleanup);
  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
}


/***/ })

}]);
//# sourceMappingURL=node_modules_stream_index_js.783de7a56296bed6fd5a.js.map